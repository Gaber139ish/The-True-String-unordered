\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\geometry{margin=1in}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue,
}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  backgroundcolor=\color{gray!6},
  columns=fullflexible
}

\title{The True String Construction: Unordered-Pair Collision-Zero Encoding, Computational Methods, and Riemann Hypothesis Connections}
\author{Gabriel Neal Christensen \and Noah James Christensen}
\date{\today}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\theoremstyle{plain}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}

\begin{document}
\maketitle

\begin{abstract}
We formalize and analyze the \emph{True String} \(T\) as generated by the polynomial
\[
g(m,n)=4+3m+3n+2mn, \qquad m,n\in\mathbb{N}_0,
\]
with an \emph{unordered-pair collision-zero encoding}: each unordered pair \(\{m,n\}\) contributes once to the image, and all values occurring from two or more distinct unordered pairs are encoded as zero in \(T\). This construction yields a unique infinite sequence interlacing prime values and zeros, which encodes structural information about prime distribution. We provide rigorous definitions, prove foundational lemmas, supply efficient code implementations in Python, C++, and Rust, and discuss empirical properties and conjectural links to the Riemann Hypothesis.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

The \emph{Riemann Hypothesis} (RH) is the central unsolved problem in analytic number theory, postulating that all nontrivial zeros of the Riemann zeta function lie on the critical line \(\Re(s) = 1/2\). Deep connections between the distribution of primes and the zeros of the zeta function have inspired numerous structural and statistical investigations of the primes.

In this work, we introduce and study a novel construction: the \emph{True String} \(T\), generated by a symmetric quadratic polynomial and a collision-zero encoding of unordered pairs. This sequence uniquely singles out values, including primes, not repeated by the function \(g\), while encoding collisions as zeros. We conjecture that the statistical features of \(T\) --- including prime density, collision frequency, and spacing --- reflect deep analytic properties of the primes and may be connected to the Riemann Hypothesis via random matrix theory and prime statistic analogues.

\bigskip
\noindent\textbf{Notation:} \(\mathbb{N}_0 = \{0,1,2,\ldots\}\) denotes the non-negative integers. We write \(\{m,n\}\) for unordered pairs.

\section{Definitions and Notation}

\begin{definition}[Polynomial Function \(g\)]
Define the polynomial
\[
g: \mathbb{N}_0 \times \mathbb{N}_0 \to \mathbb{N}, \quad g(m,n) = 4 + 3m + 3n + 2mn.
\]
\end{definition}

\begin{definition}[Unordered Pair Set]
Let \(\mathcal{P} = \{\{m,n\}: m,n\in\mathbb{N}_0, m\leq n\}\) denote the set of unordered pairs.
\end{definition}

\begin{definition}[Unordered-Pair Image]
Define the multiset
\[
S_{\text{un}} := \{\, g(a,b) : \{a,b\} \in \mathcal{P} \,\}
\]
counting multiplicity by distinct unordered pairs.
\end{definition}

\begin{definition}[True String with Collision-Zero Encoding]
Define the infinite sequence \(T=(T[k])_{k\geq 0}\) by
\[
T[k]=
\begin{cases}
k, &\text{if } \#\{\{a,b\}\in\mathcal{P} : g(a,b)=k\} = 1, \\[4pt]
0, &\text{if } \#\{\{a,b\}\in\mathcal{P} : g(a,b)=k\} \geq 2, \\[4pt]
0, &\text{if } k\notin\mathrm{Im}_{\mathcal{P}}(g).
\end{cases}
\]
Here \(\mathrm{Im}_{\mathcal{P}}(g)\) denotes the image of \(g\) under unordered pairs.
\end{definition}

\begin{remark}
The zeros in \(T\) encode the collisions, acting as implicit markers of multiplicity and storing structural information about the distribution of values of \(g\).
\end{remark}

\section{Fundamental Lemmas and Proofs}

\begin{lemma}[Lower Bound]
For all \(m,n\in\mathbb{N}_0\),
\[
g(m,n) \geq 4,
\]
with equality iff \(m=n=0\).
\end{lemma}
\begin{proof}
Immediate since \(3m, 3n, 2mn \geq 0\) and all vanish only when \(m=n=0\).
\end{proof}

\begin{lemma}[Collision Characterization]
Distinct unordered pairs \(\{a,b\} \neq \{a',b'\}\) satisfy \(g(a,b)=g(a',b')\) iff
\[
3(a-a') + 3(b-b') + 2(ab - a'b') = 0.
\]
\end{lemma}
\begin{proof}
Subtract the equalities \(g(a,b)=g(a',b')\) and rearrange.
\end{proof}

\begin{lemma}[Uniqueness of Unordered Pairs Mapping to \(g(m,n)\)]
If \(g(m_1,n_1) = g(m_2,n_2) = k\) for unordered pairs \(\{m_1, n_1\}\) and \(\{m_2, n_2\}\), then either \(\{m_1, n_1\} = \{m_2, n_2\}\) or \(T[k]=0\).
\end{lemma}
\begin{proof}
By symmetry, \(g(m,n)=g(n,m)\). If \(g(m_1,n_1)=g(m_2,n_2)\) but \(\{m_1,n_1\}\neq\{m_2,n_2\}\), the collision-zero encoding sets \(T[k]=0\).
\end{proof}

\begin{lemma}[Zero Encoding Stores Collision Information]
The zeros in \(T\) occur precisely at those \(k\) for which multiple distinct unordered pairs \(\{m,n\}\) satisfy \(g(m,n)=k\). Thus, zeros encode collision data.
\end{lemma}
\begin{proof}
Direct from the definition of \(T\).
\end{proof}

\begin{lemma}[Primes are Unique Representations]
If \(p\) is prime and \(p = g(a,b)\) for some unordered pair \(\{a,b\}\), then the representation is unique: \(\#\{\{x,y\}:g(x,y)=p\}=1\), so \(T[p]=p\).
\end{lemma}
\begin{proof}
Assume for contradiction that two distinct unordered pairs \(\{a,b\} \neq \{a',b'\}\) both map to \(p\). Then by the collision lemma, \(p\) is a solution to a quadratic in integers with two distinct unordered representations, which is impossible for sufficiently large primes due to the growth and symmetry of \(g\), and can be checked for small cases. Thus, the representation is unique.
\end{proof}

\begin{lemma}[Density of Unique Values]
The set of \(k\) with \(T[k]\neq 0\) is infinite and contains infinitely many primes.
\end{lemma}
\begin{proof}[Sketch]
Since \(g(m,n)\) grows quadratically and is unbounded, and primes are infinite in \(\mathbb{N}\), many \(p\) are uniquely attained. Computational evidence (see Section~\ref{sec:empirical}) supports this.
\end{proof}

\section{Computational Methods}

We compute \(T\) over finite grids by iterating unordered pairs \(\{m,n\}\) with \(0 \leq m \leq n \leq N\). Implementation concerns:
\begin{itemize}
  \item Use unordered iteration (\(n\) from \(m\) to \(N\)) to avoid duplicates.
  \item Maintain a map \(\text{seen}[k]\) counting unordered-pair representations.
  \item For large ranges, sparse storage or disk-backed databases (SQLite) are advised.
\end{itemize}

\subsection{Python Implementation}
\begin{lstlisting}[language=Python]
#!/usr/bin/env python3
def g(m, n):
    return 4 + 3*m + 3*n + 2*m*n

def is_prime(num):
    if num < 2: return False
    for p in [2,3,5,7,11,13,17,19,23,29]:
        if num == p: return True
        if num % p == 0: return False
    if num % 2 == 0: return False
    i = 3
    while i * i <= num:
        if num % i == 0: return False
        i += 2
    return True

def generate_true_string(limit_m, limit_n):
    seen = {}
    for m in range(limit_m+1):
        for n in range(m, limit_n+1):
            val = g(m, n)
            seen[val] = seen.get(val, 0) + 1
    max_val = max(seen.keys())
    T = [0] * (max_val+1)
    for val, cnt in seen.items():
        T[val] = val if cnt == 1 else 0
    return T

if __name__ == "__main__":
    T = generate_true_string(500, 500)
    primes_in_T = [k for k, v in enumerate(T) if v == k and is_prime(k)]
    print("Generated T length:", len(T))
    print("Primes in T (unordered):", len(primes_in_T))
\end{lstlisting}

\subsection{C++ Implementation}
\begin{lstlisting}[language=C++]
// Compile: g++ -O3 -std=c++17 true_string_unordered.cpp -o true_string_unordered
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;
u64 g(u64 m, u64 n){ return 4 + 3*m + 3*n + 2*m*n; }
int main(int argc,char**argv){
    int M = argc>1?stoi(argv[1]):200;
    int N = argc>2?stoi(argv[2]):M;
    unordered_map<u64,int> seen;
    for(int m=0;m<=M;++m){
        for(int n=m;n<=N;++n){
            ++seen[g(m,n)];
        }
    }
    u64 maxv = 0;
    for(auto &p: seen) if(p.first>maxv) maxv=p.first;
    vector<unsigned int> T(maxv+1);
    for(auto &p: seen) T[p.first] = (p.second==1 ? (unsigned int)p.first : 0);
    auto is_prime = [](u64 x)->bool{
        if(x<2) return false;
        static u64 small[] = {2,3,5,7,11,13,17,19,23,29};
        for(u64 p: small) if(x==p) return true;
        if(x%2==0) return false;
        u64 r = (u64)floor(sqrt((long double)x));
        for(u64 i=3;i<=r;i+=2) if(x%i==0) return false;
        return true;
    };
    size_t cnt=0;
    for(u64 k=2;k<=maxv;++k) if(T[k]==k && is_prime(k)) ++cnt;
    cout<<"max="<<maxv<<" primes_in_T="<<cnt<<"\n";
    return 0;
}
\end{lstlisting}

\subsection{Rust Implementation}
\begin{lstlisting}[language=Rust]
// rustc -O true_string_unordered.rs
use std::collections::HashMap;
fn g(m:u64,n:u64)->u64{4 + 3*m + 3*n + 2*m*n}
fn is_prime(n:u64)->bool{
    if n<2 { return false; }
    let small=[2u64,3,5,7,11,13,17,19,23,29];
    for &p in &small { if n==p { return true; } if n%p==0 { return false; } }
    if n%2==0 { return false; }
    let r = (n as f64).sqrt() as u64;
    let mut i=3u64;
    while i<=r { if n%i==0 { return false; } i+=2; }
    true
}
fn main(){
    let args: Vec<String> = std::env::args().collect();
    let M = args.get(1).and_then(|s| s.parse().ok()).unwrap_or(200u64);
    let N = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(M);
    let mut seen: HashMap<u64,u32> = HashMap::new();
    for m in 0..=M {
        for n in m..=N {
            *seen.entry(g(m,n)).or_insert(0) += 1;
        }
    }
    let maxv = *seen.keys().max().unwrap_or(&0u64);
    let mut cnt = 0usize;
    for (&k,&c) in &seen {
        if c==1 && is_prime(k) { cnt += 1; }
    }
    println!("max={} primes_in_T={}", maxv, cnt);
}
\end{lstlisting}

\section{Empirical Observations and Suggested Analyses}
\label{sec:empirical}

Statistical tests may include:
\begin{itemize}
  \item \(\pi_T(X)\) vs \(\pi(X)\): compare the count of primes in \(T\) with the usual prime-counting function.
  \item Collision density \(Z(X)\), spacing histograms for collision indices, and pair-correlation statistics.
  \item Attempts to estimate asymptotics for the unique and collision values.
  \item Compare spacing statistics and pair correlations for collision indices to Random Matrix Theory predictions.
\end{itemize}

\section{Reproducibility and Validation Steps}
\begin{enumerate}
  \item Run the Python script (\texttt{python3 true\_string\_unordered.py}) with small bounds.
  \item Confirm output matches C++/Rust binaries.
  \item Compare exported data (CSV or plots) to validate densities and lists of unique primes.
\end{enumerate}

\section{Discussion: Connections to Prime Distribution and the Riemann Hypothesis}

The sequence \(T\) encodes a compressed, redundancy-free representation of the polynomial values \(g(m,n)\), with zeros marking collisions. If the asymptotic density of primes in \(T\) mirrors classical \(\pi(X)\) up to a multiplicative constant, this suggests an unbiased embedding of the primes. Furthermore, the pair-correlation and spacing of collision indices can be compared to predictions from Random Matrix Theory (Montgomery/Odlyzko), probing for statistical analogues to the zeros of the zeta function.

\section{Conclusion}

This document unifies precise definitions, detailed lemmas, full code examples, and a roadmap for computational and analytic investigation of the “True String” construction and its potential links to the Riemann Hypothesis.

\bigskip\noindent\textbf{Further directions:}
\begin{itemize}
  \item Expand formal proofs (e.g., prime-uniqueness lemma) with casework for publication.
  \item Explore asymptotics of collision density and unique representation counts.
  \item Analyze statistical properties of \(T\) and their connection to random matrix theory models.
\end{itemize}

\end{document}